
3.4.2011

#

The ~:[fail~;pass~] part of the FORMAT directive causes FORMAT to print "fail" 
if the first argument is false and "pass" otherwise.
    
    (format t "~:[fail~;pass~]" (< 1 2))

#

Whenever you want to treat code as data, that's a sure sign you need a macro.

3.3.2011

#

You can create a property list with the same LIST function as you use to create
other lists.

    (list :a 1 :b 2 :c 3)
    (getf (list :a 1 :b 2 :c 3) :c)

#

The asterisks(*) in the name are a Lisp naming convention for global variables.

    (defvar *db* nil)

#

macro push, push item place, prepends item to the list that is stored in place,
 stores the resulting list in place, and returns the list.

#

When FORMAT sees ~{ the next argument to be consumed must be a list. FORMAT
  loops that list, processing the directives between the ~{ and ~}, consuming as
many elements of the list as needed each time through the list.

    (format t "~{~a~}" '(a b c))

#

The with-open-file macro opens a file,  binds the stream to a variable, executes
a set of expressions, and then close the file.

    (with-open-file (out filename
                     :direction :output
                     :if-exists :supersede)
        (with-standard-io-syntax
            (print *db* out)))

#

When we call a function which has keyword parameters, we must write :parameter,
no more spaces between ':' and parameter.

#

    (defun testfn (&key (name "abc" name-p))
        (values name name-p))

If we pass name parameter, name-p will be T, otherwise it will be nil.

2.28.2011

#

defvar is similar to defparameter, which establish name as a dynamic variable.

    (defvar *var-name*)
    (defvar *var-name* 1)

Note: the character '*' is a part of the symbol:
    
    (values *var-name*)

#

We can use (load "filename") in clisp to load a lisp code file, and then we can
call these functions defined in that file.

#

Unlike macro in C, macro in Lisp is much more like a function:


    (defmacro as (tag content)
        `(format t "<~(~A~)>~A</~(~A~)>"
                   ',tag ,content ',tag))

Here, we can use 'as' (as center "String").

#

defstruct can have some structure options like: ,type, constructor.
    
    (defstruct (html-process (:type list) 
                (:constructor make-html-process (a b c)))
        a b c)

:type explicitly specifies the representation to be used for the structure. It
can be :vector/list. 

:constructor sepcifies the constructor function name.


