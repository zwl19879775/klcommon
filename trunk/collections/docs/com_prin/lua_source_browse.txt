TODO:
* lexer
* parser
* vm
* code generator
* object structure
* api
# run-time info
# table

concept:
first-class function
closure
reflection
lambda

Recommended reading order:

lmathlib.c, lstrlib.c: get familiar with the external C API. Don't bother with the pattern matcher though. Just the easy functions. 
lapi.c: Check how the API is implemented internally. Only skim this to get a feeling for the code. Cross-reference to lua.h and luaconf.h as needed. 
lobject.h: tagged values and object representation. skim through this first. you'll want to keep a window with this file open all the time. 
lstate.h: state objects. ditto. 
lopcodes.h: bytecode instruction format and opcode definitions. easy. 
lvm.c: scroll down to luaV_execute, the main interpreter loop. see how all of the instructions are implemented. skip the details for now. reread later. 
ldo.c: calls, stacks, exceptions, coroutines. tough read. 
lstring.c: string interning. cute, huh? 
ltable.c: hash tables and arrays. tricky code. 
ltm.c: metamethod handling, reread all of lvm.c now. 
You may want to reread lapi.c now. 
ldebug.c: surprise waiting for you. abstract interpretation is used to find object names for tracebacks. does bytecode verification, too. 
lparser.c, lcode.c: recursive descent parser, targetting a register-based VM. start from chunk() and work your way through. read the expression parser and the code generator parts last. 
lgc.c: incremental garbage collector. take your time. 
Read all the other files as you see references to them. Don't let your stack get too deep though. 
If you're done before X-Mas and understood all of it, you're good. The information density of the code is rather high.

-------------------------------------------------------------------------------
global_State是一个全局的state，被多个lua_State共享。

index2adr函数将一个整数栈索引转换为栈元素指针，这里的栈元素都是TValue类型；
lua_State::base对应于栈底，lua_State::top对应于栈顶。

api_check宏基本就是个简单的assert。

api_incr_top宏用于增加栈空间: t->top++。

lua_atpanic用于设置一个异常处理回调函数，仅仅于luaD_throw中调用，调用后紧接着
exit代码。

TValue是栈元素类型，它是一个典型的value-type的结构体。

lua_pushXXX系列的函数都是直接往lua_State::top写一个TValue，然后top增长。


4.16.2010
lopcodes.h中定义了虚拟机中的指令类型。一条指令默认只用一个32字节的数表示，其中6
字节是操作码，剩下的字节数是操作数。

MASK1( n, p ) 将一条指令的第p个位后的n个位置为1，MASK0(n,p)与此相反：全部置0。

通过luaP_opmodes数组将每个指令的属性（如操作码类型、操作数类型等）事先记录，然后
通过getOpMode、getBMode之类的宏取得这些属性。

OpMode用于描述操作码类型；OpArgMask描述操作数类型。

lcode.c中 luaK_code用于生成一条指令，指令保存于FuncState::Proto::code数组。

  luaM_growvector(fs->L, f->code, fs->pc, f->sizecode, Instruction,
                  MAX_INT, "code size overflow");
  f->code[fs->pc] = i;
  /* save corresponding line information */
  luaM_growvector(fs->L, f->lineinfo, fs->pc, f->sizelineinfo, int,
                  MAX_INT, "code size overflow");
  f->lineinfo[fs->pc] = line;

luaM_growvector用于扩充f->code容量，可以看出f->pc表示当前大小，f->sizecode表示最
大的大小。


4.19.2010
ltable.c中实现了lua中的table结构，从lua_newtable函数跟进去，luaH_new分配了一个表
，然后在lua_newtable中将其强转为GCObject放置于栈顶。

lua中的表针对数组和非数组做了2组不同的实现。如果表是以数字作为索引，那么lua就实
现为一个数组，否则就使用hash来实现。

Table结构表示一个表。

4.20.2010
LUA的各个寄存器都直接位于lua_State:base指向的栈里，出现在指令中的是寄存器索引，
索引于该栈内部。

lvm.c中RA、RB之类的宏用于直接从指令中取出寄存器索引。

Proto:k是一个存储常量的数组，其元素类型依然为TValue。k指向第一个元素。

全局变量保存于全局表中，全局表保存于LClosure:env中。

4.21.2010
global_State是一个全局状态，被一个主lua_State和其下的所有thread共享。注册表位于
其中：global_State:l_registry。

lua_State:l_gt是全局表(G表)，每一次lua_newthead时，将此指针复制给新的thead。

lua_newstate用于创建一个独立的lua_State，这个独立的state其实是一个struct LG：
typedef struct LG {
	lua_State l;
	global_State g;
} LG:

global_State在此被创建。

lstring.c实现了LUA中对字符串的管理：基于HASH表和链表的结构。LUA中字符串都由
TString描述，TString结构本身只描述字符串信息，字符串内容保存于该结构体后的内存位
置：

  ts = cast(TString *, luaM_malloc(L, (l+1)*sizeof(char)+sizeof(TString)));

global_State:strt保存了虚拟机环境中所有的字符串，相同的字符串只有一份拷贝。



